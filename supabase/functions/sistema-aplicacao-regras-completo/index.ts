import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface RegraAplicacao {
  nome: string;
  funcao: string;
  parametros: any;
  arquivo_aplicavel: string[];
  condicao_aplicacao?: (arquivo: string) => boolean;
  validacao_pos_aplicacao?: (supabase: any, arquivo: string, resultado: any) => Promise<boolean>;
}

interface StatusAplicacao {
  regra: string;
  arquivo: string;
  aplicada: boolean;
  resultado?: any;
  erro?: string;
  validacao_ok?: boolean;
}

// Defini√ß√£o completa de TODAS as regras do sistema
const REGRAS_SISTEMA: RegraAplicacao[] = [
  // 1. REGRA DE PER√çODO ATUAL (v031) - APENAS para arquivos n√£o-retroativos
  {
    nome: "v031_filtro_periodo_atual",
    funcao: "aplicar-exclusoes-periodo",
    parametros: (arquivo: string, periodo: string) => ({ arquivo_fonte: arquivo, periodo_referencia: periodo }),
    arquivo_aplicavel: ['volumetria_padrao', 'volumetria_fora_padrao', 'volumetria_onco_padrao'], // N√ÉO retroativos
    validacao_pos_aplicacao: async (supabase, arquivo, resultado) => {
      // Para n√£o-retroativos: verificar se filtrou corretamente por per√≠odo atual
      return true; // Regra sempre passa pois √© de filtro
    }
  },
  
  // 2. REGRAS DE PER√çODO RETROATIVO (v002/v003) - APENAS para arquivos retroativos  
  {
    nome: "v002_v003_exclusoes_periodo",
    funcao: "aplicar-exclusoes-periodo", 
    parametros: (arquivo: string, periodo: string) => ({ arquivo_fonte: arquivo, periodo_referencia: periodo }),
    arquivo_aplicavel: ['volumetria_padrao_retroativo', 'volumetria_fora_padrao_retroativo'], // APENAS retroativos
    validacao_pos_aplicacao: async (supabase, arquivo, resultado) => {
      // Validar se realmente foram exclu√≠dos registros conforme esperado
      if (arquivo.includes('retroativo')) {
        // Para retroativos: verificar se n√£o h√° mais registros com DATA_REALIZACAO >= 01/jun
        const { count } = await supabase
          .from('volumetria_mobilemed')
          .select('*', { count: 'exact', head: true })
          .eq('arquivo_fonte', arquivo)
          .gte('DATA_REALIZACAO', '2025-06-01');
        return count === 0; // Deveria ser 0 ap√≥s v003
      }
      return true;
  },
  
  // 3. CORRE√á√ÉO DE MODALIDADES (DX/CR ‚Üí RX)
  {
    nome: "correcao_modalidades_dx_cr",
    funcao: "aplicar-correcao-modalidade-rx",
    parametros: (arquivo: string) => ({ arquivo_fonte: arquivo }),
    arquivo_aplicavel: ['volumetria_padrao', 'volumetria_fora_padrao', 'volumetria_padrao_retroativo', 'volumetria_fora_padrao_retroativo', 'volumetria_onco_padrao'], // Arquivos 1,2,3,4,5
    validacao_pos_aplicacao: async (supabase, arquivo, resultado) => {
      // Verificar se ainda existem modalidades DX/CR que deveriam ser RX
      const { count } = await supabase
        .from('volumetria_mobilemed')
        .select('*', { count: 'exact', head: true })
        .eq('arquivo_fonte', arquivo)
        .in('MODALIDADE', ['DX', 'CR'])
        .not('ESTUDO_DESCRICAO', 'ilike', '%mamografia%')
        .not('ESTUDO_DESCRICAO', 'ilike', '%mamogra%')
        .not('ESTUDO_DESCRICAO', 'ilike', '%tomo%');
      return count === 0; // N√£o deveria ter DX/CR n√£o-mamogr√°ficos
  },
  
  // 4. CORRE√á√ÉO DE MODALIDADES (OT ‚Üí DO)
  {
    nome: "correcao_modalidades_ot",
    funcao: "aplicar-correcao-modalidade-ot",
    parametros: (arquivo: string) => ({ arquivo_fonte: arquivo }),
    arquivo_aplicavel: ['volumetria_padrao', 'volumetria_fora_padrao', 'volumetria_padrao_retroativo', 'volumetria_fora_padrao_retroativo'],
    validacao_pos_aplicacao: async (supabase, arquivo, resultado) => {
      // Verificar se ainda existem modalidades OT (deveriam ter sido convertidas para DO)
      const { count } = await supabase
        .from('volumetria_mobilemed')
        .select('*', { count: 'exact', head: true })
        .eq('arquivo_fonte', arquivo)
        .eq('MODALIDADE', 'OT');
      return count === 0; // N√£o deveria ter modalidade OT
    }
  },
  
  // 4. DE-PARA PRIORIDADES
  {
    nome: "de_para_prioridades",
    funcao: "aplicar-de-para-prioridades", 
    parametros: (arquivo: string) => ({ arquivo_fonte: arquivo }),
    arquivo_aplicavel: ['volumetria_padrao', 'volumetria_fora_padrao', 'volumetria_padrao_retroativo', 'volumetria_fora_padrao_retroativo', 'volumetria_onco_padrao'], // Todos os arquivos
    validacao_pos_aplicacao: async (supabase, arquivo, resultado) => {
      // Verificar se ainda h√° prioridades n√£o padronizadas (usando aspas duplas)
      const { count } = await supabase
        .from('volumetria_mobilemed')
        .select('*', { count: 'exact', head: true })
        .eq('arquivo_fonte', arquivo)
        .not('"PRIORIDADE"', 'in', '("ROTINA","URG√äNCIA","PLANT√ÉO")');
      return count === 0;
    }
  },
  
  // 5. DE-PARA VALORES ZERADOS
  {
    nome: "de_para_valores_zerados",
    funcao: "aplicar-regras-tratamento",
    parametros: (arquivo: string) => ({ arquivo_fonte: arquivo }),
    arquivo_aplicavel: ['volumetria_padrao', 'volumetria_fora_padrao', 'volumetria_padrao_retroativo', 'volumetria_fora_padrao_retroativo'],
    validacao_pos_aplicacao: async (supabase, arquivo, resultado) => {
      // Verificar quantos valores zerados ainda existem (deveria ser m√≠nimo)
      const { count } = await supabase
        .from('volumetria_mobilemed')
        .select('*', { count: 'exact', head: true })
        .eq('arquivo_fonte', arquivo)
        .or('VALORES.is.null,VALORES.eq.0');
      
      // Aceitar at√© 5% de valores zerados (alguns podem n√£o ter de-para)
      const { count: total } = await supabase
        .from('volumetria_mobilemed')
        .select('*', { count: 'exact', head: true })
        .eq('arquivo_fonte', arquivo);
      
      return total > 0 ? (count / total) <= 0.05 : true;
    }
  },
  
  // 6. TIPIFICA√á√ÉO DE FATURAMENTO
  {
    nome: "tipificacao_faturamento",
    funcao: "aplicar-tipificacao-faturamento",
    parametros: (arquivo: string) => ({ arquivo_fonte: arquivo }),
    arquivo_aplicavel: ['volumetria_padrao', 'volumetria_fora_padrao', 'volumetria_padrao_retroativo', 'volumetria_fora_padrao_retroativo'],
    validacao_pos_aplicacao: async (supabase, arquivo, resultado) => {
      // Verificar se todos os registros t√™m tipo_faturamento
      const { count } = await supabase
        .from('volumetria_mobilemed')
        .select('*', { count: 'exact', head: true })
        .eq('arquivo_fonte', arquivo)
        .or('tipo_faturamento.is.null,tipo_faturamento.eq.""');
      return count === 0;
    }
  },
  
  // 7. VALIDA√á√ÉO DE CLIENTE
  {
    nome: "validacao_cliente",
    funcao: "aplicar-validacao-cliente",
    parametros: (arquivo: string, lote: string) => ({ arquivo_fonte: arquivo, lote_upload: lote }),
    arquivo_aplicavel: ['volumetria_padrao', 'volumetria_fora_padrao', 'volumetria_padrao_retroativo', 'volumetria_fora_padrao_retroativo'],
    validacao_pos_aplicacao: async (supabase, arquivo, resultado) => {
      return true; // Valida√ß√£o sempre passa (n√£o √© cr√≠tica para falha)
    }
  }
];

export default serve(async (req: Request): Promise<Response> => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { 
      arquivo_fonte, 
      lote_upload, 
      periodo_referencia,
      forcar_aplicacao = false,
      validar_apenas = false 
    } = await req.json();

    if (!arquivo_fonte) {
      throw new Error('arquivo_fonte √© obrigat√≥rio');
    }

    console.log(`üéØ SISTEMA DE APLICA√á√ÉO COMPLETA DE REGRAS`);
    console.log(`üìÅ Arquivo: ${arquivo_fonte}`);
    console.log(`üì¶ Lote: ${lote_upload || 'N/A'}`);
    console.log(`üìÖ Per√≠odo: ${periodo_referencia || 'jun/25'}`);
    console.log(`üîÑ For√ßar aplica√ß√£o: ${forcar_aplicacao}`);
    console.log(`‚úÖ Apenas validar: ${validar_apenas}`);

    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const statusAplicacao: StatusAplicacao[] = [];
    const periodo = periodo_referencia || 'jun/25';

    // Filtrar regras aplic√°veis ao arquivo
    const regrasApplicaveis = REGRAS_SISTEMA.filter(regra => 
      regra.arquivo_aplicavel.includes(arquivo_fonte)
    );

    console.log(`üìã ${regrasApplicaveis.length} regras aplic√°veis encontradas para ${arquivo_fonte}`);

    // Aplicar cada regra na ordem correta
    for (const regra of regrasApplicaveis) {
      console.log(`\nüîß Aplicando: ${regra.nome}`);
      
      const status: StatusAplicacao = {
        regra: regra.nome,
        arquivo: arquivo_fonte,
        aplicada: false
      };

      if (validar_apenas) {
        // Apenas validar se a regra foi aplicada corretamente
        if (regra.validacao_pos_aplicacao) {
          try {
            const validacaoOk = await regra.validacao_pos_aplicacao(supabase, arquivo_fonte, null);
            status.validacao_ok = validacaoOk;
            status.aplicada = validacaoOk;
            console.log(`‚úÖ Valida√ß√£o ${regra.nome}: ${validacaoOk ? 'OK' : 'FALHOU'}`);
          } catch (error) {
            status.erro = error.message;
            console.log(`‚ùå Erro na valida√ß√£o ${regra.nome}: ${error.message}`);
          }
        } else {
          status.aplicada = true; // Sem valida√ß√£o = assume OK
        }
      } else {
        // Aplicar a regra
        try {
          let parametros;
          if (typeof regra.parametros === 'function') {
            // Passar argumentos corretos baseado no que a fun√ß√£o espera
            if (regra.nome.includes('periodo')) {
              parametros = regra.parametros(arquivo_fonte, periodo);
            } else {
              parametros = regra.parametros(arquivo_fonte);
            }
          } else {
            parametros = regra.parametros;
          }
          
          console.log(`üöÄ Executando ${regra.funcao} com par√¢metros:`, parametros);

          const { data: resultado, error } = await supabase.functions.invoke(regra.funcao, {
            body: parametros
          });

          if (error) {
            throw new Error(`Erro na fun√ß√£o ${regra.funcao}: ${error.message}`);
          }

          status.resultado = resultado;
          status.aplicada = true;
          
          console.log(`‚úÖ ${regra.nome} aplicada com sucesso:`, resultado);

          // Validar p√≥s-aplica√ß√£o se definida
          if (regra.validacao_pos_aplicacao) {
            const validacaoOk = await regra.validacao_pos_aplicacao(supabase, arquivo_fonte, resultado);
            status.validacao_ok = validacaoOk;
            
            if (!validacaoOk) {
              console.log(`‚ö†Ô∏è FALHA NA VALIDA√á√ÉO: ${regra.nome} n√£o produziu resultado esperado!`);
              if (forcar_aplicacao) {
                console.log(`üîÑ Tentando aplicar novamente...`);
                // Tentar aplicar novamente
                const { data: resultadoReaplicacao } = await supabase.functions.invoke(regra.funcao, {
                  body: parametros
                });
                const validacaoReaplicacao = await regra.validacao_pos_aplicacao(supabase, arquivo_fonte, resultadoReaplicacao);
                status.validacao_ok = validacaoReaplicacao;
                console.log(`üéØ Reaplica√ß√£o: ${validacaoReaplicacao ? 'SUCESSO' : 'AINDA FALHOU'}`);
              }
            } else {
              console.log(`‚úÖ Valida√ß√£o ${regra.nome}: OK`);
            }
          }

        } catch (error) {
          status.erro = error.message;
          status.aplicada = false;
          console.log(`‚ùå Erro ao aplicar ${regra.nome}: ${error.message}`);
        }
      }

      statusAplicacao.push(status);
    }

    // Resumo final
    const totalRegras = statusAplicacao.length;
    const regrasAplicadas = statusAplicacao.filter(s => s.aplicada).length;
    const regrasComValidacao = statusAplicacao.filter(s => s.validacao_ok === true).length;
    const regrasFalharam = statusAplicacao.filter(s => s.validacao_ok === false).length;

    const sucesso = regrasAplicadas === totalRegras && regrasFalharam === 0;

    console.log(`\nüéØ RESUMO FINAL:`);
    console.log(`üìä Total de regras: ${totalRegras}`);
    console.log(`‚úÖ Regras aplicadas: ${regrasAplicadas}`);
    console.log(`üîç Regras validadas OK: ${regrasComValidacao}`);
    console.log(`‚ùå Regras que falharam na valida√ß√£o: ${regrasFalharam}`);
    console.log(`üèÜ Sucesso geral: ${sucesso ? 'SIM' : 'N√ÉO'}`);

    return new Response(JSON.stringify({
      success: sucesso,
      arquivo_fonte,
      lote_upload,
      periodo_referencia: periodo,
      total_regras: totalRegras,
      regras_aplicadas: regrasAplicadas,
      regras_validadas_ok: regrasComValidacao,
      regras_falharam: regrasFalharam,
      status_detalhado: statusAplicacao,
      recomendacao: sucesso 
        ? "Todas as regras foram aplicadas e validadas com sucesso"
        : "Algumas regras falharam. Verifique o status detalhado e execute novamente com forcar_aplicacao=true",
      timestamp: new Date().toISOString()
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('üí• Erro no sistema de aplica√ß√£o de regras:', error);
    
    return new Response(JSON.stringify({
      success: false,
      error: error.message
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
});